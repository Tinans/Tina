{"version":3,"sources":["index.js","axios/index.js","axios/utils.js","axios/core/request.js","axios/core/mergeConfig.js","axios/core/dispatchRequest.js","axios/core/interceptorManager.js","axios/defaults.js","axios/core/cancelToken.js","axios/core/graphQL.js","axios/core/logger.js","weux/index.js","weux/moduleCollection.js","helper/utils.js","observer/reactive.js","observer/dep.js","weux/mapFactory.js","globalProxy/globalPage.js","observer/index.js","observer/computed.js","observer/watcher.js","observer/traverse.js","observer/scheduler.js","observer/watch.js","observer/updateComputed.js","navigate/index.js","navigate/navigateTo.js","globalProxy/globalData.js","helper/handleData.js","helper/hookEvent.js","eventBus/index.js","helper/diff.js","globalProxy/globalComponent.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AGRA,AFMA,ACHA,AFMA;AIXA,ADGA,AFMA,ACHA,AFMA;AIXA,ADGA,AFMA,ACHA,AFMA;AIXA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ADGA,ADGA,AFMA,ACHA,AFMA;AKdA,ACHA,AFMA,ADGA,AFMA,ACHA,AFMA;AKdA,ACHA,AFMA,ADGA,AFMA,ACHA,AFMA;AKdA,ACHA,AFMA,ADGA,AFMA,ACHA,AFMA;AKdA,ACHA,AFMA,ADGA,AIZA,ANkBA,ACHA,AFMA;AKdA,ACHA,AFMA,ADGA,AIZA,ANkBA,ACHA,AFMA;AKdA,ACHA,AFMA,ADGA,AIZA,ANkBA,ACHA,AFMA;AQvBA,AHSA,ACHA,AFMA,ADGA,AIZA,ANkBA,ACHA,AFMA;AQvBA,AHSA,ACHA,AFMA,ADGA,AIZA,ANkBA,ACHA;AMjBA,AHSA,ACHA,AFMA,ADGA,AIZA,ALeA;AMjBA,AHSA,AIZA,AHSA,AFMA,ADGA,AIZA,ALeA;AMjBA,AHSA,AIZA,AHSA,AFMA,ADGA,AIZA,ALeA;AMjBA,AHSA,AIZA,AHSA,AFMA,ADGA,AIZA,ALeA;AMjBA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA;AMjBA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA;AMjBA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA;AMjBA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AS3BA;AHUA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AS3BA;AHUA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AS3BA;AHUA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AS3BA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AS3BA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AS3BA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AFMA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AFMA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AFMA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AWjCA,ACHA,AHSA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AWjCA,ACHA,AHSA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AWjCA,ACHA,AHSA,ACHA;AJaA,AHSA,AIZA,AHSA,AIZA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AENA,ADGA,AHSA,ACHA;AJaA,AHSA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AENA,ADGA,AHSA,ACHA;AJaA,AHSA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AENA,ADGA,AHSA,ACHA;AJaA,AHSA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AENA,ADGA,AHSA,AKfA,AJYA;AJaA,AHSA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AENA,ADGA,AHSA,AKfA,AJYA;AJaA,AHSA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,AWjCA,AENA,ADGA,AHSA,AKfA,AJYA;AJaA,AHSA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AENA,ADGA,AHSA,AKfA,AJYA;AJaA,AHSA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AENA,ADGA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AENA,ADGA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AENA,AGTA,AJYA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AENA,AGTA,AJYA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AENA,AGTA,AJYA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AMlBA,AJYA,AGTA,AJYA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AMlBA,AJYA,AGTA,AJYA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,AIZA,ALeA,Ae7CA,AJYA,AMlBA,AJYA,AGTA,AJYA,AHSA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,ADGA,Ae7CA,AJYA,AMlBA,AJYA,AGTA,AJYA,AMlBA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,ANkBA,ADGA,ADGA,Ae7CA,AJYA,AMlBA,AJYA,ADGA,AMlBA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,ADGA,Ae7CA,AJYA,AMlBA,AJYA,ADGA,AMlBA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,ADGA,Ae7CA,AJYA,AMlBA,AJYA,ADGA,AOrBA,ADGA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,ADGA,Ae7CA,AJYA,AMlBA,AJYA,ADGA,AOrBA,ADGA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,ADGA,Ae7CA,AJYA,AMlBA,AJYA,ADGA,AOrBA,ADGA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,ADGA,Ae7CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,ADGA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,ADGA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,ADGA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,AENA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,AENA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,AENA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AMlBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AYpCA,ANkBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AYpCA,ANkBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AYpCA,ANkBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA,AJYA;APsBA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ACHA,APqBA,Ac1CA,AJYA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,Ac1CA,AJYA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AJYA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AJYA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AJYA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AWjCA,Af6CA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AWjCA,Af6CA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AWjCA,Af6CA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AWjCA,ACHA,AhBgDA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,ADGA,AGTA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AWjCA,ACHA,AhBgDA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,AwBxEA,AV8BA,AWjCA,ACHA,AhBgDA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AHSA,AV8BA,AWjCA,ACHA,AhBgDA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AHSA,AV8BA,AWjCA,ACHA,AhBgDA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AHSA,AV8BA,AWjCA,ACHA,AhBgDA,AYpCA,ACHA,APqBA,AJYA,ADGA,AQxBA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AHSA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AHSA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AHSA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,ANkBA,A2BjFA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;AXkCA,AIZA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ALeA,AV8BA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,Af6CA,Ac1CA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AqB/DA,AENA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,ACHA,AhBgDA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,Af6CA,AavCA,APqBA,AGTA,AENA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,Af6CA,AavCA,APqBA,AKfA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,Af6CA,AavCA,APqBA,AKfA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,Af6CA,AavCA,AFMA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,Af6CA,AavCA,AFMA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AHSA,Af6CA,AavCA,AFMA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AavCA,AFMA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AavCA,AFMA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AavCA,AFMA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AWjCA,ADGA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AU9BA,AHSA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AuBrEA,ADGA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA,AKfA;APsBA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AOrBA,AT2BA;AFOA,AsBlEA,AlBsDA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AIZA,AFMA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('../weapp/axios/index');var axios = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./weux/index');var Store = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./weux/mapFactory');var mapState = __TEMP__['mapState'];var mapMutations = __TEMP__['mapMutations'];var mapActions = __TEMP__['mapActions'];var mapGetters = __TEMP__['mapGetters'];var createNamespacedHelpers = __TEMP__['createNamespacedHelpers'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./globalProxy/globalPage');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./globalProxy/globalComponent');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = {\n  axios,\n  Store,\n  mapState,\n  mapMutations,\n  mapActions,\n  mapGetters,\n  createNamespacedHelpers\n};\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'axios', { enumerable: true, configurable: true, get: function() { return axios; } });Object.defineProperty(exports, 'Store', { enumerable: true, configurable: true, get: function() { return Store; } });Object.defineProperty(exports, 'mapState', { enumerable: true, configurable: true, get: function() { return mapState; } });Object.defineProperty(exports, 'mapMutations', { enumerable: true, configurable: true, get: function() { return mapMutations; } });Object.defineProperty(exports, 'mapActions', { enumerable: true, configurable: true, get: function() { return mapActions; } });Object.defineProperty(exports, 'mapGetters', { enumerable: true, configurable: true, get: function() { return mapGetters; } });Object.defineProperty(exports, 'createNamespacedHelpers', { enumerable: true, configurable: true, get: function() { return createNamespacedHelpers; } });\n\n\n\n\n\n\n\n","var __TEMP__ = require('./utils');var deepMerge = __TEMP__['deepMerge'];var extend = __TEMP__['extend'];\nvar __TEMP__ = require('./core/request');var Request = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./defaults');var defaults = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./core/cancelToken');var CancelToken = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./core/graphQL');var graphQL = __REQUIRE_DEFAULT__(__TEMP__);\n\nfunction createInstance(config) {\n\tconst context = new Request(config)\n\tconst instance = Request.prototype.request.bind(context)\n\textend(instance, context)\n\treturn instance\n}\n\nconst request = createInstance(defaults)\n\nrequest.create = function (config) {\n\treturn createInstance(deepMerge(defaults, config))\n}\n\nrequest.CancelToken = CancelToken\nrequest.graphQL = graphQL\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = request;","const _toString = Object.prototype.toString\n\nconst typeClass = {\n\tdate: '[object Date]',\n\tobject: '[object Object]'\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isDate(val) {\n\treturn _toString.call(val) === typeClass['date']\n};exports.isDate = isDate\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isObject(val) {\n\treturn val !== null && typeof val === 'object'\n};exports.isObject = isObject\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isPlainObject(val) {\n\treturn _toString.call(val) === typeClass['object']\n};exports.isPlainObject = isPlainObject\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function extend(_to, _from) {\n\tconst requestAPI = ['request', 'get', 'delete', 'head', 'options', 'post', 'put', 'patch', '_requestMethodWithData', '_requestMethodWithoutData']\n\tfor (const key in _from) {\n\t\t_to[key] = _from[key]\n\t}\n\trequestAPI.forEach(key => {\n\t\t_to[key] = _from[key]\n\t})\n\treturn _to\n};exports.extend = extend\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function deepMerge(...obj) {\n\tconst result = {}\n\tobj.forEach(item => {\n\t\tif (!item) return\n\t\tObject.keys(item).forEach(key => {\n\t\t\tconst val = item[key]\n\t\t\tif (isPlainObject(val)) {\n\t\t\t\tif (isPlainObject(result[key])) {\n\t\t\t\t\tresult[key] = deepMerge(result[key], val)\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = deepMerge(val)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[key] = val\n\t\t\t}\n\t\t})\n\t})\n\treturn result\n};exports.deepMerge = deepMerge\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function flattenHeaders(headers, method) {\n\tif (!headers) {\n\t\treturn headers\n\t}\n\theaders = deepMerge(headers.common || {}, headers[method] || {}, headers)\n\tconst methodsToDelete = ['delete', 'get', 'head', 'options', 'post', 'put', 'patch', 'common']\n\tmethodsToDelete.forEach(method => {\n\t\tdelete headers[method]\n\t})\n\treturn headers\n};exports.flattenHeaders = flattenHeaders","var __TEMP__ = require('./mergeConfig');var mergeConfig = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./dispatchRequest');var dispatchRequest = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./interceptorManager');var InterceptorManager = __REQUIRE_DEFAULT__(__TEMP__);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });class Request {\n\tconstructor(config) {\n\t\tthis.defaults = config\n\t\tthis.interceptors = {\n\t\t\trequest: new InterceptorManager(),\n\t\t\tresponse: new InterceptorManager()\n\t\t}\n\t}\n\n\trequest(url, config = {}) {\n\t\tif (typeof url === 'string') {\n\t\t\tconfig.url = url\n\t\t} else {\n\t\t\tconfig = url\n\t\t}\n\n\t\tconst originConfig = config\n\t\tconfig = mergeConfig(this.defaults, config)\n\t\tconfig.originConfig = originConfig\n\t\tconst promiseChain = [{\n\t\t\tresolved: dispatchRequest,\n\t\t\trejected: undefined\n\t\t}]\n\n\t\tthis.interceptors.request.forEach(interceptor => promiseChain.unshift(interceptor))\n\t\tthis.interceptors.response.forEach(interceptor => promiseChain.push(interceptor))\n\t\tlet promise = Promise.resolve(config)\n\t\t\n\t\twhile (promiseChain.length) {\n\t\t\tconst {\n\t\t\t\tresolved,\n\t\t\t\trejected\n\t\t\t} = promiseChain.shift()\n\t\t\tpromise = promise.then(resolved, rejected)\n\t\t}\n\t\t\n\t\treturn promise\n\t}\n\n\tget(url, config) {\n\t\treturn this._requestMethodWithoutData('get', url, config)\n\t}\n\n\tdelete(url, config) {\n\t\treturn this._requestMethodWithoutData('delete', url, config)\n\t}\n\n\thead(url, config) {\n\t\treturn this._requestMethodWithoutData('head', url, config)\n\t}\n\n\toptions(url, config) {\n\t\treturn this._requestMethodWithoutData('options', url, config)\n\t}\n\n\tpost(url, data, config) {\n\t\treturn this._requestMethodWithData('post', url, data, config)\n\t}\n\n\tput(url, data, config) {\n\t\treturn this._requestMethodWithData('put', url, data, config)\n\t}\n\n\tpatch(url, data, config) {\n\t\treturn this._requestMethodWithData('patch', url, data, config)\n\t}\n\n\t_requestMethodWithoutData(method, url, config) {\n\t\treturn this.request(\n\t\t\tObject.assign(config || {}, {\n\t\t\t\tmethod,\n\t\t\t\turl\n\t\t\t})\n\t\t)\n\t}\n\n\t_requestMethodWithData(method, url, data, config) {\n\t\treturn this.request(\n\t\t\tObject.assign(config || {}, {\n\t\t\t\tmethod,\n\t\t\t\turl,\n\t\t\t\tdata\n\t\t\t})\n\t\t)\n\t}\n};exports.default = Request","var __TEMP__ = require('../utils');var isPlainObject = __TEMP__['isPlainObject'];var deepMerge = __TEMP__['deepMerge'];\n\nconst strats = Object.create(null)\n\nconst defaultStratKeys = ['url', 'params', 'key']\n\nconst deepMergeStratKeys = ['headers']\n\ndefaultStratKeys.forEach(key => {\n\tstrats[key] = defaultStrat\n})\n\ndeepMergeStratKeys.forEach(key => {\n\tstrats[key] = deepMergeStrat\n})\n\nfunction defaultStrat(val1, val2) {\n\treturn typeof val2 !== 'undefined' ? val2 : val1\n}\n\nfunction deepMergeStrat(val1, val2) {\n\tif (isPlainObject(val2)) {\n\t\treturn deepMerge(val1, val2)\n\t} else if (typeof val2 !== 'undefined') {\n\t\treturn val2\n\t} else if (isPlainObject(val1)) {\n\t\treturn deepMerge(val1)\n\t} else if (typeof val1 !== 'undefined') {\n\t\treturn val1\n\t}\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function mergeConfig(config1, config2 = {}) {\n\tconst config = {}\n\tfor (const key in config2) {\n\t\tmergeField(key)\n\t}\n\n\tfor (const key in config1) {\n\t\tif (!config2[key]) {\n\t\t\tmergeField(key)\n\t\t}\n\t}\n\n\tfunction mergeField(key) {\n\t\tconst strat = strats[key] || defaultStrat\n\t\tconfig[key] = strat(config1[key], config2[key])\n\t}\n\treturn config\n};exports.default = mergeConfig","var __TEMP__ = require('../utils');var flattenHeaders = __TEMP__['flattenHeaders'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function dispatchRequest(config) {\n\tprocressConfig(config)\n\treturn wxRequest(config).then(res => {\n\t\treturn transformResponse(res, config)\n\t})\n};exports.default = dispatchRequest\n\nfunction procressConfig(config) {\n\tconfig.headers = transformHeaders(config)\n\tconfig.url = transformURL(config.baseURL, config.url)\n\tconfig.method = (config.method || 'GET').toUpperCase()\n}\n\nfunction transformURL(baseURL = '', url) {\n\treturn baseURL + url\n}\n\nfunction transformHeaders(config) {\n\tconst headers = flattenHeaders(config.headers, config.method)\n\tconst { auth, authKey, authURL, url } = config\n\tif (authURL.exclusive && authURL.exclusive.includes(url)) {\n\t\treturn headers\n\t}\n\tif (authURL.inclusive && !authURL.inclusive.includes(url)) {\n\t\treturn headers\n\t}\n\tif (auth &&\n\t\tauthKey &&\n\t\ttypeof authKey === 'string' &&\n\t\theaders[authKey] === undefined &&\n\t\theaders[authKey.toLowerCase()] === undefined) {\n\t\t\tconst authType = typeof config.auth\n\t\t\tlet authStr = ''\n\t\t\tif (authType === 'string') {\n\t\t\t\tauthStr = auth\n\t\t\t} else if (authType === 'function') {\n\t\t\t\tauthStr = auth()\n\t\t\t}\n\t\t\tif (authStr && typeof authStr === 'string') {\n\t\t\t\theaders[authKey] = authStr\n\t\t\t}\n\t}\n\t\treturn headers\n}\n\nfunction transformResponse(res, config) {\n\tres.config = config\n\treturn res\n}\n\nfunction wxRequest(config) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst {\n\t\t\turl,\n\t\t\tmethod,\n\t\t\tdata,\n\t\t\tparams,\n\t\t\ttimeout,\n\t\t\theaders: header,\n\t\t\tdataType = 'json',\n\t\t\tresponseType = 'text',\n\t\t\tcancelToken\n\t\t} = config\n\t\tconst requestTask = wx.request({\n\t\t\turl,\n\t\t\tmethod,\n\t\t\tdata: method === 'GET' ? params : data,\n\t\t\theader,\n\t\t\ttimeout,\n\t\t\tdataType,\n\t\t\tresponseType,\n\t\t\tsuccess: res => resolve(res),\n\t\t\tfail: err => reject(err),\n\t\t\tcomplete: () => { }\n\t\t})\n\t\tif (cancelToken) {\n\t\t\tcancelToken.promise.then(reason => {\n\t\t\t\trequestTask.abort()\n\t\t\t\treject(reason)\n\t\t\t})\n\t\t}\n\t})\n}","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });class InterceptorManager {\n\tconstructor() {\n\t\tthis.interceptors = []\n\t}\n\n\tuse(resolved, rejected) {\n\t\tthis.interceptors.push({\n\t\t\tresolved,\n\t\t\trejected\n\t\t})\n\t\t\n\t\treturn this.interceptors.length - 1\n\t}\n\n\tforEach(fn) {\n\t\tthis.interceptors.forEach(interceptor => {\n\t\t\tif (interceptor !== null) {\n\t\t\t\tfn(interceptor)\n\t\t\t}\n\t\t})\n\t}\n\n\teject(id) {\n\t\tif (this.interceptors[id]) {\n\t\t\tthis.interceptors[id] = null\n\t\t}\n\t}\n};exports.default = InterceptorManager","const defaults = {\n\tmethod: 'GET',\n\n\ttimeout: 0,\n\n\theaders: {\n\t\tcommon: {\n\t\t\tAccept: 'application/json, text/plain, */*'\n\t\t}\n\t},\n\n\tbaseURL: '',\n\n\tauth: null, // {null | String | Function}\n\n\tauthKey: 'Authorization',\n\n\tauthURL: {\n\t\tinclusive: null,\n\t\texclusive: null\n\t} // {null | String[]}\n}\n\nconst methodsNoData = ['delete', 'get', 'head', 'options']\n\nmethodsNoData.forEach(method => {\n\tdefaults.headers[method] = {}\n})\n\nconst methodsWithData = ['post', 'put', 'patch']\n\nmethodsWithData.forEach(method => {\n\tdefaults.headers[method] = {\n\t\t'Content-Type': 'application/json;charset=utf-8'\n\t}\n})\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = defaults;\n","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });class CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function')\n    }\n\n    let resolvePromise = null\n    this.promise = new Promise(resolve => {\n      resolvePromise = resolve\n    })\n    executor(message => {\n      if (this.reason) return\n      this.reason = message  ? `Cancel: ${message}` : 'Canceled'\n      resolvePromise(this.reason)\n    })\n  }\n};exports.default = CancelToken\n\nCancelToken.source = function source() {\n  let cancel\n  let token = new CancelToken(function executor(c) {\n    cancel = c\n  })\n  \n  return {\n    token,\n    cancel\n  }\n}","var __TEMP__ = require('./request');var Request = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../utils');var deepMerge = __TEMP__['deepMerge'];\nvar __TEMP__ = require('../defaults');var defaults = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./logger');var requestStart = __TEMP__['requestStart'];var requestEndError = __TEMP__['requestEndError'];var requestEnd = __TEMP__['requestEnd'];\n\nconst cache = {}\n\n/**\n * Request的graphQL扩展\n */\nclass graphQL {\n    constructor(config = {}) {\n        this.client = new Request(deepMerge(defaults, config))\n        this.config = config\n        if (config.custom !== 'undefined') {\n            this.isCustomQueryStatement = !!config.custom\n        } else {\n            this.isCustomQueryStatement = false\n        }\n    }\n    /**\n     * @property {String} query query查询语句\n     * @property {Object} variables 查询参数\n     */\n    query(data, config = {}) {\n        const type = 'query'\n        return this.dispatchRequest(data, config, type, 'query')\n    }\n    /**\n     * @property {String} mutation mutation查询语句\n     * @property {Object} variables 查询参数\n     */\n    mutate(data, config = {}) {\n        const type = 'mutation'\n        data.query = data.mutation\n        return this.dispatchRequest(data, config, type, 'mutate')\n    }\n    dispatchRequest(data, config, type, handleType) {\n        let { query, variables = {}, responseNode, custom } = data\n        if (!(query = formatQuery(query))) {\n            return Promise.reject()\n        }\n        let queryStatement = ''\n        let isCustomQueryStatement\n        let variablesWithScoped = {}\n        let ast = null\n        if (typeof custom === 'boolean') {\n            isCustomQueryStatement = custom\n        } else {\n            isCustomQueryStatement = this.isCustomQueryStatement\n        }\n        if (isCustomQueryStatement) {\n            queryStatement = query\n        } else {\n            const cacheKey = query.join('/') + responseNode || ''\n            if (cache[cacheKey]) {\n                queryStatement = cache[cacheKey]\n            } else {\n                try {\n                    ast = parse(query, responseNode, type, variables)\n                    // queryStatement = cache[cacheKey] = gencode(ast)\n                    queryStatement = gencode(ast)\n                    variablesWithScoped = getVariablesWithScoped(ast)\n                    if (this.config.logger) {\n                        requestStart(ast, variablesWithScoped)\n                    }\n                } catch (err) {\n                    cache[cacheKey] = ''\n                    console.error(err)\n                    return Promise.reject()\n                }\n            }\n        }\n        config = Object.assign({}, config, {\n            isGql: true,\n            gql: ast\n        })\n        return this.client.post(this.config.url, { query: queryStatement, variables: variablesWithScoped }, config).then(\n            res => {\n                if (this.config.logger) {\n                    requestEnd(ast, res)\n                }\n                return Promise.resolve(res)\n            },\n            err => {\n                if (this.config.logger) {\n                    requestEndError(ast, err)\n                }\n                return Promise.reject(err)\n            }\n        )\n    }\n}\n\nfunction parse(queries, responseNode, type, variables) {\n    if (!responseNode) {\n        responseNode = {}\n    }\n    const isOnlyQuery = queries.length === 1\n    // const resultMap = {}\n    const resultArr = []\n    queries.forEach(query => {\n        const ast = parseQuery(query, responseNode, type, variables, isOnlyQuery)\n        // resultMap[ast.operationName] = ast\n        resultArr.push(ast)\n    })\n    return resultArr\n}\n\n/**\n * @param {Object[]} ast query的ast\n */\nfunction gencode(ast) {\n    let result = ''\n    const operationType = ast[0].operationType\n    const operationName = ast.map(item => item.operationName).join('_')\n    const variablesScoped = getVariablesScoped(ast)\n    const variablesStatement = variablesScoped.length > 0 ? `(${variablesScoped.join(',')})` : ''\n    result += `${operationType} ${operationName}${variablesStatement}{\n        ${createMainStatement(ast)}\n    }`\n    function getVariablesScoped(ast) {\n        const _v = []\n        ast.forEach(item => {\n            const { operationName, variables } = item\n            _v.push(...variables.map(({ key, type }) => {\n                return `$${operationName}_${key}:${type}`\n            }))\n        })\n        return _v\n    }\n    function createMainStatement(ast) {\n        let _s = ''\n        ast.forEach(item => {\n            const { operationName, variables, responseNode } = item\n            const hasVariables = variables && variables.length > 0\n            _s += operationName\n            if (hasVariables) {\n                const _vs = variables.map(({ key }) => `${key}:$${operationName}_${key}`).join(',')\n                _s += `(${_vs})`\n            }\n            if (responseNode) {\n                _s += `{${responseNode}}`\n            }\n            _s += `↵`\n        })\n        return _s\n    }\n    return result\n}\n\n/**\n *\n * @param {String|String[]} query\n */\nfunction formatQuery(query) {\n    if (!query) {\n        return false\n    }\n    if (typeof query === 'string') {\n        return [query]\n    }\n    if (Array.isArray(query)) {\n        if (query.some(item => typeof item !== 'string')) {\n            console.error(`query为数组时需要是 \"string[]\" 类型`)\n            return false\n        }\n        return query\n    }\n    console.error('query只支持 string 和 string[] 类型')\n    return false\n}\n\n/**\n *\n * @param {String} query query语句\n * @param {String | Object} responseNode 返回节点声明\n * @param {String}} type 操作类型\n * @param {Object} variables 变量\n */\nfunction parseQuery(query, responseNode, type, variables, isOnlyQuery) {\n    query = query.trim()\n    const contentReg = /\\(([^)]*)\\)/\n    const result = {}\n    let match = query.match(contentReg)\n    if (!match) {\n        query += '()'\n        match = query.match(contentReg)\n        if (!match) {\n            throw new Error(`${query}语法错误`)\n        }\n    }\n    const variablesStatement = match[1]\n    const operationIdx = match['index']\n    const operationName = query.substr(0, operationIdx)\n    if (!operationName) {\n        throw new Error(`缺少操作名称: ${query}`)\n    }\n    result.operationName = operationName\n    result.variables = []\n    result.variablesMap = {}\n    if (variablesStatement) {\n        variablesStatement.split(',').forEach(item => {\n            let [key, type] = item.split(':')\n            key = key.trim()\n            type = type.trim()\n            if (!type) {\n                throw new Error(`变量\"${key}\"缺少类型: ${query}`)\n            }\n            result.variables.push({ key, type })\n            result.variablesMap[key] = type\n        })\n    }\n    if (typeof responseNode === 'string') {\n        responseNode = { [operationName]: responseNode }\n    }\n    result.variablesStore = isOnlyQuery ? variables : (variables[operationName] || {})\n    result.responseNode = responseNode[operationName] || ''\n    result.operationType = type\n    return result\n}\n\nfunction getVariablesWithScoped(ast) {\n    const result = {}\n    if (ast && ast.length > 0) {\n        ast.forEach(item => {\n            const { operationName, variablesStore } = item\n            Object.keys(variablesStore).forEach(key => {\n                result[`${operationName}_${key}`] = variablesStore[key]\n            })\n        })\n    }\n    return result\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = graphQL;","const loggerMap = {}\n\nfunction getOperationName(ast) {\n    return ast.map(item => item.operationName).join('_')\n}\n\nfunction getOperationType(ast) {\n    return ast[0].operationType\n}\n\nfunction transAst(ast) {\n    return {\n        name: getOperationName(ast),\n        type: getOperationType(ast)\n    }\n}\n\nfunction printLog(loggerItem) {\n    const { request, response, type, name } = loggerItem\n    console.log(`%c ${type} : ${name} `, `background-color:${type === 'query' ? '#00ff00' : '#ffc400'};color:#000`)\n    console.log('请求', request.variables)\n    console.log('响应', response)\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function requestStart(ast, variables) {\n    const { name, type } = transAst(ast)\n    loggerMap[name] = {\n        request: {\n            variables\n        },\n        response: {},\n        type,\n        name\n    }\n};exports.requestStart = requestStart\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function requestEnd(ast, res) {\n    const { name } = transAst(ast)\n    if (name && loggerMap[name]) {\n        loggerMap[name].response = res\n        printLog(loggerMap[name])\n    }\n};exports.requestEnd = requestEnd\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function requestEndError(ast, err) {\n    const { name, type } = transAst(ast)\n    console.log(`%c ${type} : ${name}  %c Error `, `background-color:${type === 'query' ? '#00ff00' : '#ffc400'};color:#000`, 'background-color:#ff0000;color:#fff')\n    console.log('AST', ast)\n    console.log('err', err)\n};exports.requestEndError = requestEndError","var __TEMP__ = require('./moduleCollection');var ModuleCollection = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../observer/reactive');var reactive = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../helper/utils');var isPromise = __TEMP__['isPromise'];var getNestedState = __TEMP__['getNestedState'];var unifyObjectStyle = __TEMP__['unifyObjectStyle'];var forEachValue = __TEMP__['forEachValue'];var forEachChild = __TEMP__['forEachChild'];var forEachMutation = __TEMP__['forEachMutation'];var forEachAction = __TEMP__['forEachAction'];var forEachGetter = __TEMP__['forEachGetter'];var isObject = __TEMP__['isObject'];var getNamespace = __TEMP__['getNamespace'];\n\n\n\n\n\n\n\n\n\n\n\n\nclass Store {\n  constructor (options = {}) {\n    this._init = false\n    this._actions = {}\n    this._mutations = {}\n    this._wrappedGetters = {}\n    this._makeLocalGettersCache = {}\n    this._modulesNamespaceMap = {}\n    this._modules = new ModuleCollection(options)\n    const state = this._states = this._modules.root.state\n    this._rawState = JSON.parse(JSON.stringify(state))\n\n    const store = this\n    const { dispatch, commit } = this\n\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n    \n    installModule(this, state, [], this._modules.root)\n    resetStoreGetter(this, state)\n  }\n\n  commit (type, payload) {\n    if (isObject(type) && type.type) {\n      payload = type\n      type = type.type\n    }\n    \n    const entry = this._mutations[type]\n    if (!entry) {\n      console.error(`[weux] unknown mutation type: ${type}`)\n      return\n    }\n    entry.forEach(handler => handler(payload))\n  }\n\n  dispatch (type, payload) {\n    if (isObject(type) && type.type) {\n      payload = type\n      type = type.type\n    }\n\n    const entry = this._actions[type]\n    if (!entry) {\n      console.error(`[weux] unknown action type: ${type}`)\n      return\n    }\n    return entry.length > 1\n      ? Promise.all(entry.map(handler => handler(payload)))\n      : entry[0](payload)\n  }\n\n  get state() {\n    if (!this._init) {\n      reactive(this._states)\n      this._init = true\n    }\n\n    return this._states\n  }\n\n  set state (val) {\n    console.error(`use store commit to explicit replace store state.`)\n  }\n}\n\nfunction resetStoreGetter (store, state) {\n  let { getters } = store._modules.root._rawModule\n  getters = getters || {}\n  \n  store.getters = {}\n  store._getters = {}\n  store._makeLocalGettersCache = Object.create(null)\n  const wrappedGetters = store._wrappedGetters\n\n  forEachValue(wrappedGetters, (fn, key) => {\n    if (getters[key]) {\n      Object.defineProperty(store._getters, key, {\n        get: () => getters[key](state),\n        enumerable: true\n      })\n    }\n\n    Object.defineProperty(store.getters, key, {\n      get: () => wrappedGetters[key](state),\n      enumerable: true\n    })\n  })\n}\n\nfunction installModule(store, rootState, path, module){\n  const namespace = getNamespace(store._modules.root, path)\n\n  if (module._rawModule.namespaced) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  const local = module.context = makeLocalContext(store, namespace, path)\n\n  forEachMutation(module, (mutation, key) => {\n    const namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n\n  forEachAction(module, (action, key) => {\n    const type = action.root ? key : namespace + key\n    const handler = action.handler || action\n    registerAction(store, type, handler, local)\n  })\n\n  forEachGetter(module, (getter, key) => {\n    const namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local)\n  })\n  \n  if (module._children) {\n      forEachChild(module, (child, key) => {\n        installModule(store, rootState, path.concat(key), child)\n      })\n  }\n}\n\nfunction makeLocalContext (store, namespace, path) {\n  const noNamespace = namespace === ''\n\n  const local = {\n    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) => {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (!store._actions[type]) {\n          console.error(`[weux] unknown local action type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : (_type, _payload, _options) => {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (!store._mutations[type]) {\n          console.error(`[weux] unknown local mutation type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      store.commit(type, payload, options)\n    }\n  }\n\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? () => store.getters\n        : () => makeLocalGetters(store, namespace)\n    },\n    state: {\n      get: () => getNestedState(store.state, path)\n    }\n  })\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  if (!store._makeLocalGettersCache[namespace]) {\n    const gettersProxy = {}\n    const splitPos = namespace.length\n    \n    if (store.getters) {\n      Object.keys(store.getters).forEach(type => {\n        if (type.slice(0, splitPos) !== namespace) return\n  \n        const localType = type.slice(splitPos)\n        Object.defineProperty(gettersProxy, localType, {\n          get: () => store.getters[type],\n          enumerable: true\n        })\n      })\n      store._makeLocalGettersCache[namespace] = gettersProxy\n    }\n  }\n\n  return store._makeLocalGettersCache[namespace]\n}\n\nfunction registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload)\n  })\n}\n\nfunction registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload) {\n    let res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    return res\n  })\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    console.error(`[weux] duplicate getter key: ${type}`)\n    return\n  }\n  \n  store._wrappedGetters[type] = function wrappedGetter () {\n    return rawGetter(\n      local.state, \n      local.getters, \n      store.state, \n      store.getters  \n    )\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Store;\n","var __TEMP__ = require('../helper/utils');var forEachChild = __TEMP__['forEachChild'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });class ModuleCollection {\n  constructor(options) {\n    this.root = null\n    this.register([], options)\n  }\n  \n  register (path, rootModule) {\n    let moduleMap = {\n      _rawModule: rootModule,\n      _children: {},\n      state: rootModule.state\n    }\n    \n    if (!this.root) {\n      this.root = moduleMap\n    } else {\n      const curModuleName = path[path.length - 1]\n      const fn = (acc, cur) => acc._children[cur]\n      const parent = path.slice(0, -1).reduce(fn, this.root)\n      parent._children[curModuleName] = moduleMap\n      \n      if (parent._children) {\n        forEachChild(parent, (child, key) => {\n          const parentState = parent.state\n          parent.state = (typeof parentState === 'function' ? parentState() : parentState) || {}\n          const childrenState = child.state\n          child.state = (typeof childrenState === 'function' ? childrenState() : childrenState) || {}\n          parent.state[key] = child.state\n        })\n      }\n    }\n    \n    const childModules = rootModule.modules\n    childModules &&\n      Object.keys(childModules).forEach(childModuleName => {\n        const curChildModule = childModules[childModuleName]\n        this.register(path.concat(childModuleName), curChildModule)\n      })\n  }\n};exports.default = ModuleCollection","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function noop () {};exports.noop = noop\n\nlet unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/\nlet bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"))\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    if (obj && obj.data) {\n        let { data } = obj\n        for (var i = 0; i < segments.length; i++) {\n        data = data[segments[i]]\n      }\n\n      return data\n    }\n\n    return obj\n  }\n};exports.parsePath = parsePath\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function equal(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = Array.isArray(a),\n        arrB = Array.isArray(b),\n        i,\n        length,\n        key\n\n    if (arrA && arrB) {\n      length = a.length\n      if (length != b.length) return false\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    if (arrA != arrB) return false\n\n    var dateA = a instanceof Date,\n        dateB = b instanceof Date\n    if (dateA != dateB) return false\n    if (dateA && dateB) return a.getTime() == b.getTime()\n\n    var regexpA = a instanceof RegExp,\n        regexpB = b instanceof RegExp\n        \n    if (regexpA != regexpB) return false\n    if (regexpA && regexpB) return a.toString() == b.toString()\n\n    var keys = Object.keys(a)\n    length = keys.length\n\n    if (length !== Object.keys(b).length)\n      return false\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i]\n      if (!equal(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  return a!==a && b!==b\n};exports.equal = equal\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isPlainObject (obj) {\n  return Object.prototype.toString.call(obj) === \"[object Object]\"\n};exports.isPlainObject = isPlainObject\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isMixObject (value) {\n  return Object.prototype.toString.call(value) === \"[object Object]\" || Array.isArray(value)\n};exports.isMixObject = isMixObject\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n};exports.isObject = isObject\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function strToUpperCase (str) {  \n  return str.toLowerCase().replace(/( |^)[a-z]/g, (L) => L.toUpperCase());  \n};exports.strToUpperCase = strToUpperCase\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isEmptyObject (obj) {\n  if (!obj) {\n    return true\n  }\n  for (let key in obj) {\n    return false\n  }\n  return true\n};exports.isEmptyObject = isEmptyObject\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isNotEmptyObject (obj) {\n  return obj !== null && typeof obj === 'object' && Object.keys(obj).length\n};exports.isNotEmptyObject = isNotEmptyObject\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function remove (arr, item) {\n  if (arr.length) {\n    const index = arr.indexOf(item)\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n};exports.remove = remove\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function once () {\n   let called = false\n   return (fn) => {\n      if (!called) {\n          called = true\n          typeof fn === 'function' && fn()\n      }\n   }\n};exports.once = once\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function asyncLock () {\n  let lock = false\n  return (fn, onerror) => {\n    if (!lock) {\n      lock = true\n      Promise.resolve().then(() => {\n        lock = false\n        typeof fn === 'function' && fn()\n      }).catch(e => {\n        lock = false\n        typeof onerror === 'function' && onerror()\n        console.error('Something wrong in wxapp asyncLock func execution, please check.', undefined, e)\n      })\n    }\n  }\n};exports.asyncLock = asyncLock\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getObjByKey (obj) {\n  const result = {}\n  Object.keys(obj).forEach(key => {\n      const keys = key.split('.')\n\n      if (keys.length > 1) {\n          if (obj[key] === null) {\n              result[key] = ''\n          } else {\n              result[key] = obj[key]\n          }\n      } else {\n          if (obj[key] !== null) {\n              result[key] = obj[key]\n          }\n      }\n  })\n\n  return result\n};exports.getObjByKey = getObjByKey\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function forEachValue (obj, fn) {\n  Object.keys(obj).forEach(key => fn(obj[key], key))\n};exports.forEachValue = forEachValue\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function forEachMutation (module, fn) {\n  if (module._rawModule.mutations) {\n    forEachValue(module._rawModule.mutations, fn)\n  }\n};exports.forEachMutation = forEachMutation\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function forEachAction (module, fn) {\n  if (module._rawModule.actions) {\n    forEachValue(module._rawModule.actions, fn)\n  }\n};exports.forEachAction = forEachAction\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function forEachChild (module, fn) {\n  forEachValue(module._children, fn)\n};exports.forEachChild = forEachChild\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function forEachGetter (module, fn) {\n  if (module._rawModule.getters) {\n    forEachValue(module._rawModule.getters, fn)\n  }\n};exports.forEachGetter = forEachGetter\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function isPromise (val) {\n  return val && typeof val.then === 'function'\n};exports.isPromise = isPromise\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function partial (fn, arg) {\n  return function () {\n    return fn(arg)\n  }\n};exports.partial = partial\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getNestedState (state, path) {\n  return path.reduce((state, key) => state[key], state)\n};exports.getNestedState = getNestedState\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload\n    payload = type\n    type = type.type\n  }\n\n  return { type, payload, options }\n};exports.unifyObjectStyle = unifyObjectStyle\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getNamespace(root, path) { \n  let rootModule = root\n  return path.reduce((namespace, key) => {\n    rootModule = rootModule._children[key]\n    return namespace + (rootModule._rawModule.namespaced ? key + '/' : '')\n  }, '')\n};exports.getNamespace = getNamespace","var __TEMP__ = require('./dep');var Dep = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../helper/utils');var isMixObject = __TEMP__['isMixObject'];var isPlainObject = __TEMP__['isPlainObject'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function observe (obj) {\n    observeTarget(obj)\n};exports.default = observe\n\nfunction observeTarget (data) {\n    if (isMixObject(data)) {\n        if (Array.isArray(data)) {\n            data.map(item => {\n               if (isPlainObject(item)) {\n                   defineReactive(item)\n               } else {\n                   observeTarget(item)\n               }\n            })\n        } else {\n            defineReactive(data)\n        }\n    }\n}\n\nfunction defineReactive (target) {\n    const dep = new Dep()\n\n    Object.keys(target).forEach(key => {\n        let value = target[key]\n\n        if (key !== '__webviewId__') {\n            Object.defineProperty(target, key, {\n                enumerable: true,\n                configurable: true,\n                get() {\n                    if (Dep.target) {\n                        dep.depend()\n                    }\n                    \n                    return value\n                },\n                set(newValue) {\n                    value = newValue\n                    observeTarget(newValue)\n                    dep.notify()\n                }\n            })\n        }\n\n        observeTarget(value)\n    })\n}","var __TEMP__ = require('../helper/utils');var remove = __TEMP__['remove'];\n\nlet uid = 0\n\nclass Dep {\n    constructor() {\n        this.subs = []\n        this.id = uid++\n    }\n    \n    addSub(sub) {\n        this.subs.push(sub)\n    }\n\n    removeSub(sub) {\n        remove(this.subs, sub)\n    }\n\n    depend() {\n        if (Dep.target) {\n            Dep.target.addDep(this)\n        }\n    }\n\n    notify() {\n        const subs = this.subs.slice()\n        \n        for (let i = 0, len = subs.length; i < len; i++) {\n            subs[i].update()\n        }\n    }\n}\n\nDep.target = null\nconst targetStack = []\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function pushTarget (_target) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n};exports.pushTarget = pushTarget\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function popTarget () {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n};exports.popTarget = popTarget\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Dep;\n","function isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var mapState = exports.mapState = normalizeNamespace((namespace, states) => {\n  const res = {}\n  if (!isValidMap(states)) {\n    console.error('[weux] mapState: mapper parameter must be either an Array or an Object')\n  }\n\n  normalizeMap(states).forEach(({ key, val }) => {\n    res[key] = function mappedState () {\n      let state = this.$store.state\n      let getters = this.$store.getters\n      \n      if (namespace) {\n        const module = getModuleByNamespace(this.$store, 'mapState', namespace)\n\n        if (!module) {\n          return\n        }\n        \n        state = module.context.state\n        getters = module.context.getters\n      }\n\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    }\n  })\n\n  return res\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var mapMutations = exports.mapMutations = normalizeNamespace((namespace, mutations) => {\n  const res = {}\n  if (!isValidMap(mutations)) {\n    console.error('[weux] mapMutations: mapper parameter must be either an Array or an Object')\n  }\n  normalizeMap(mutations).forEach(({ key, val }) => {\n    res[key] = function mappedMutation (...args) {\n      let commit = this.$store.commit\n      if (namespace) {\n        const module = getModuleByNamespace(this.$store, 'mapMutations', namespace)\n        if (!module) {\n          return\n        }\n        \n        commit = module.context.commit\n      }\n\n      return typeof val === 'function'\n        ? val.apply(this, [commit].concat(args))\n        : commit.apply(this.$store, [val].concat(args))\n    }\n  })\n  \n  return res\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var mapGetters = exports.mapGetters = normalizeNamespace((namespace, getters) => {\n  const res = {}\n  if (!isValidMap(getters)) {\n    console.error('[weux] mapGetters: mapper parameter must be either an Array or an Object')\n  }\n  normalizeMap(getters).forEach(({ key, val }) => {\n    val = namespace + val\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n\n      if (!(val in this.$store.getters)) {\n        console.error(`[weux] unknown getter: ${val}`)\n        return\n      }\n\n      return this.$store.getters[val]\n    }\n  })\n\n  return res\n});\n\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var mapActions = exports.mapActions = normalizeNamespace((namespace, actions) => {\n  const res = {}\n  if (!isValidMap(actions)) {\n    console.error('[weux] mapActions: mapper parameter must be either an Array or an Object')\n  }\n  normalizeMap(actions).forEach(({ key, val }) => {\n    res[key] = function mappedAction (...args) {\n      let dispatch = this.$store.dispatch\n      if (namespace) {\n        const module = getModuleByNamespace(this.$store, 'mapActions', namespace)\n        if (!module) {\n          return\n        }\n\n        dispatch = module.context.dispatch\n      }\n\n      return typeof val === 'function'\n        ? val.apply(this, [dispatch].concat(args))\n        : dispatch.apply(this.$store, [val].concat(args))\n    }\n  })\n\n  return res\n});\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var createNamespacedHelpers = exports.createNamespacedHelpers = (namespace) => ({\n  mapState: mapState.bind(null, namespace),\n  mapGetters: mapGetters.bind(null, namespace),\n  mapMutations: mapMutations.bind(null, namespace),\n  mapActions: mapActions.bind(null, namespace)\n});\n\nfunction normalizeMap (map) {\n  if (!isValidMap(map)) {\n    return []\n  }\n\n  return Array.isArray(map)\n    ? map.map(key => ({ key, val: key }))\n    : Object.keys(map).map(key => ({ key, val: map[key] }))\n}\n\n\nfunction isValidMap (map) {\n  return Array.isArray(map) || isObject(map)\n}\n\nfunction normalizeNamespace (fn) {\n  return (namespace, map) => {\n    if (typeof namespace !== 'string') {\n      map = namespace\n      namespace = ''\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/'\n    }\n\n    return fn(namespace, map)\n  }\n}\n\nfunction getModuleByNamespace (store, helper, namespace) {\n  const module = store._modulesNamespaceMap[namespace]\n  \n  if (!module) {\n    console.error(`[weux] module namespace not found in ${helper}(): ${namespace}`)\n  }\n\n  return module\n}\n","var __TEMP__ = require('../observer/index');var initState = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../observer/watch');var initWatch = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../navigate/index');var linkTo = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../navigate/navigateTo');var route = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./globalData');var globalData = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../observer/updateComputed');var updateComputed = __TEMP__['updateComputed'];\nvar __TEMP__ = require('../helper/handleData');var handleData = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../observer/updateComputed');var ctxTarget = __TEMP__['ctxTarget'];\nvar __TEMP__ = require('../helper/hookEvent');var hookEvent = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst originalPage = Page\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Page = function (options = {}) {\n  options.$global = globalData\n  options.$route = route\n\n  const lifeTimesBackup = {\n    onLoad: options.onLoad,\n    onShow: options.onShow,\n    onHide: options.onHide,\n    onUnload: options.onUnload,\n  }\n\n  options.onLoad = function (config) {\n    hookEvent(this)\n    const { data, computed } = this\n    initState(this, data, computed)\n    \n    wx.nextTick(() => {\n       handleData(this)\n    })\n\n    lifeTimesBackup.onLoad && lifeTimesBackup.onLoad.call(this, config)\n  }\n\n  options.onShow = function () {\n    initWatch(this, this.watch)\n    updateComputed('showUpdate')\n    lifeTimesBackup.onShow && lifeTimesBackup.onShow.call(this)\n  }\n\n  options.onHide = function () {\n    const ctxResult = ctxTarget()\n    ctxResult.map(ctx => {\n       ctx._rawBack = ctx._rawData\n       ctx._rawStringify = JSON.stringify(ctx._rawData)\n    })\n    \n    lifeTimesBackup.onHide && lifeTimesBackup.onHide.call(this)\n  }\n\n  options.onUnload = function () {\n    const computedWatchers = this._computedWatchers\n    if (computedWatchers && Object.keys(computedWatchers).length) {\n        Object.keys(computedWatchers).forEach(key => computedWatchers[key].teardown())\n    }\n\n    this._rawData = null\n    this._computedWatchers = null\n    this.$store = null\n    this.$bus = null\n\n    lifeTimesBackup.onUnload && lifeTimesBackup.onUnload.call(this)\n  }\n\n  options.routeTo = function (e) {\n    return linkTo(e)\n  }\n\n  return originalPage(options)\n};","var __TEMP__ = require('./reactive');var reactive = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./computed');var initComputed = __REQUIRE_DEFAULT__(__TEMP__);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function initState (ctx, target, computed) {\n    reactive(target)\n    initComputed(ctx, target, computed)\n};exports.default = initState","var __TEMP__ = require('./watcher');var Watcher = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../helper/utils');var noop = __TEMP__['noop'];\nvar __TEMP__ = require('./updateComputed');var addStack = __TEMP__['addStack'];var updateComputed = __TEMP__['updateComputed'];\nvar __TEMP__ = require('./dep');var Dep = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function initComputed (ctx, target, computed) {\n    addStack(ctx)\n\n    const computedMap = {}\n    const watchers = ctx._computedWatchers = {}\n    ctx._computedMap = {}\n\n    for (const key in computed) {\n        const userDef = computed[key]\n        const getter = typeof userDef === 'function' ? userDef.bind(ctx) : userDef.get\n        \n        if (key in target) {\n            console.error(`The computed property \"${key}\" is already defined in data`)\n            continue\n        } else {\n            defineComputed(ctx, target, key, userDef)\n        }\n\t\t\n        const watcher = watchers[key] = new Watcher(ctx, getter || noop, () => {\n           ctx._computedMap[key] = watcher.value\n           updateComputed()\n        }, { lazy: true })\n        \n        computedMap[key] = target[key]\n    }\n    \n    try {\n        ctx.setData(computedMap)\n    } catch (e) {\n        throw e\n    }\n};exports.default = initComputed\n\nfunction defineComputed (ctx, target, key, userDef) {\n    if (typeof userDef === 'function') {\n        sharedPropertyDefinition.get = createComputedGetter(ctx, key)\n        sharedPropertyDefinition.set = noop\n    } else {\n        sharedPropertyDefinition.get = userDef.get\n          ? createComputedGetter(ctx, key)\n          : noop\n\n        sharedPropertyDefinition.set = userDef.set\n          ? userDef.set.bind(ctx)\n          : noop\n    }\n    \n    Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n\nfunction createComputedGetter (ctx, key) {\n    return () => {\n      const watcher = ctx._computedWatchers && ctx._computedWatchers[key]\n      \n      if (watcher) {\n        if (watcher.dirty) {\n            watcher.evaluate()\n        }\n        \n        if (Dep.target) {\n            watcher.depend()\n        }\n        \n        return watcher.value\n      }\n    }\n  }\n","var __TEMP__ = require('./dep');var Dep = __REQUIRE_DEFAULT__(__TEMP__);var pushTarget = __TEMP__['pushTarget'];var popTarget = __TEMP__['popTarget'];\nvar __TEMP__ = require('./traverse');var traverse = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./scheduler');var queueWatcher = __TEMP__['queueWatcher'];\nvar __TEMP__ = require('../helper/utils');var noop = __TEMP__['noop'];var parsePath = __TEMP__['parsePath'];var equal = __TEMP__['equal'];var isObject = __TEMP__['isObject'];\nvar __TEMP__ = require('./watch');var invokeWithWatch = __TEMP__['invokeWithWatch'];\n\nlet uid = 0\n\nclass Watcher {\n    constructor(vm, fn, cb, options) {\n        this.vm = vm\n        this.fn = fn\n        this.cb = cb\n        this.id = ++uid\n        this.deps = []\n        this.newDeps = []\n        this.depIds = new Set()\n        this.newDepIds = new Set()\n        this.active = true\n        this.add = false\n        this.invoke = true\n        \n        if (options) {\n            this.deep = !!options.deep\n            this.user = !!options.user\n            this.lazy = !!options.lazy\n            this.sync = !!options.sync\n        } else {\n            this.deep = this.user = this.lazy = this.sync = false\n        }\n        \n        if (typeof fn === 'function') {\n            this.getter = fn\n        } else {\n            this.getter = parsePath(fn)\n            if (!this.getter) {\n                this.getter = noop\n                console.warn(`Failed watching path: ${getter} Watcher only accepts simple dot-delimited paths.For full control, use a function instead.`)\n            }\n        }\n\n        this.dirty = this.lazy\n        this.value = this.lazy ? undefined : this.getWatcher()\n    }\n    evaluate() {\n        this.value = this.getWatcher()\n        this.dirty = false\n    }\n    getWatcher() {\n        pushTarget(this)\n        let value\n        try {\n            value = this.getter.call(this.vm, this.vm)\n        } catch (e) {\n            throw e\n        } finally {\n            if (this.deep) {\n                if (!this.add) {\n                    this.deepVal = JSON.parse(JSON.stringify(value))\n                    this.add = true\n                }\n                traverse(value)\n            }\n\n            popTarget()\n            this.cleanupDeps()\n        }\n        \n        return value\n    }\n    update() {\n      if (this.lazy) {\n          this.dirty = true\n          let oldValue = this.value\n          let newValue = this.getter.call(this.vm, this.vm)\n          \n          if (!equal(oldValue, newValue)) {\n              this.value = newValue\n              typeof this.cb === 'function' && this.cb.call(this.vm)\n          }\n        } else if (this.sync) {\n           this.run()\n        } else {\n           queueWatcher(this)\n        }\n    }\n    run() {\n      if (this.active) {\n        let value = this.getWatcher()\n        \n        if (\n          value !== this.value ||\n          isObject(value) ||\n          this.deep\n        ) {\n          let oldVal\n          if (this.deep) {\n              oldVal = this.deepVal\n              if (equal(oldVal, value)) {\n                  this.invoke = false\n              } else {\n                  this.invoke = true\n              }\n\n              this.deepVal = JSON.parse(JSON.stringify(value))\n          } else {\n              oldVal = this.value\n          }\n          this.value = value\n          \n          if (this.invoke) {\n            if (this.user) {\n                try {\n                    invokeWithWatch(this, value, oldVal)\n                } catch (e) {\n                    console.error(e)\n                }\n            } else {\n                invokeWithWatch(this, value, oldVal)\n            }\n          }\n        }\n      }\n    }\n    addDep(dep) {\n      const id = dep.id\n\n      if (!this.newDepIds.has(id)) {\n          this.newDepIds.add(id)\n          this.newDeps.push(dep)\n\n          if (!this.depIds.has(id)) {\n              dep.addSub(this)\n          }\n      }\n    }\n    cleanupDeps() {\n        let i = this.deps.length\n        while (i--) {\n          const dep = this.deps[i]\n          if (!this.newDepIds.has(dep.id)) {\n            dep.removeSub(this)\n          }\n        }\n\n        let tmp = this.depIds\n        this.depIds = this.newDepIds\n        this.newDepIds = tmp\n        this.newDepIds.clear()\n        tmp = this.deps\n        this.deps = this.newDeps\n        this.newDeps = tmp\n        this.newDeps.length = 0\n    }\n    depend() {\n        if (Dep.target) {\n            let i = this.deps.length\n            while (i--) {\n                this.deps[i].depend()\n            }\n        }\n    }\n    teardown() {\n        if (this.active) {\n          let i = this.deps.length\n          while (i--) {\n            this.deps[i].removeSub(this)\n          }\n          this.active = false\n        }\n    }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Watcher;\n","var __TEMP__ = require('../helper/utils');var isObject = __TEMP__['isObject'];\n\nconst seenObjects = new Set()\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function traverse (val) {\n  seenObjects.clear()\n  _traverse(val, seenObjects)\n};exports.default = traverse\n\nfunction _traverse (val, seen) {\n  let i, keys\n  const isA = Array.isArray(val)\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  \n  if (isA) {\n    i = val.length\n    while (i--) _traverse(val[i], seen)\n  } else {\n    keys = Object.keys(val)\n    i = keys.length\n    while (i--) _traverse(val[keys[i]], seen)\n  }\n}","var __TEMP__ = require('../helper/utils');var asyncLock = __TEMP__['asyncLock'];\n\nconst queue = []\nlet has = {}\nlet circular = {}\nlet flushing = false\nlet curIndex = 0\nconst lockTask = asyncLock()\nconst MAX_UPDATE_COUNT = 100\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function queueWatcher (watcher) {\n  if (!watcher.id && typeof watcher === 'function') {\n    watcher = {\n      id: Infinity,\n      run: watcher\n    }\n  }\n  \n  if (!has[watcher.id] || watcher.id === Infinity) {\n    has[watcher.id] = true\n    if (!flushing) {\n      queue.push(watcher)\n      lockTask(flushQueue, resetQueue)\n    } else {\n      let i = queue.length - 1\n      while (i > curIndex && watcher.id < queue[i].id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n  }\n};exports.queueWatcher = queueWatcher\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function dequeueWatcher (watcher) {\n  if (!watcher.id || !has[watcher.id]) return\n  const index = queue.indexOf(watcher)\n  if (index > -1) {\n    queue.splice(index, 1)\n    has[watcher.id] = false\n  }\n};exports.dequeueWatcher = dequeueWatcher\n\nfunction flushQueue () {\n  flushing = true\n  queue.sort((a, b) => a.id - b.id)\n  for (curIndex = 0; curIndex < queue.length; curIndex++) {\n    const watcher = queue[curIndex]\n    const id = watcher.id\n    if (id !== Infinity) {\n      delete has[id]\n      circular[id] = (circular[id] || 0) + 1\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          let location = watcher.vm && watcher.vm.is\n          console.error(`You may have a dead circular update in watcher with expression, please check!`, location)\n          break\n        }\n    }\n    \n    watcher.run()\n  }\n  resetQueue()\n}\n\nfunction resetQueue () {\n  flushing = false\n  curIndex = queue.length = 0\n  has = {}\n  circular = {}\n}","var __TEMP__ = require('./watcher');var Watchers = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../helper/utils');var isObject = __TEMP__['isObject'];var noop = __TEMP__['noop'];var strToUpperCase = __TEMP__['strToUpperCase'];\nvar __TEMP__ = require('./updateComputed');var ctxTarget = __TEMP__['ctxTarget'];\nlet called = false\nconst watchMap = new Map()\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function initWatch (ctx, watch) {\n  for (let key in watch) {\n    let handler = watch[key]\n\n    if (Array.isArray(handler)) {\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(ctx, key, handler[i])\n      }\n    } else {\n      createWatcher(ctx, key, handler)\n    }\n  }\n};exports.default = initWatch\n\nfunction createWatcher (ctx, fn, cb, options) {\n  if (isObject(cb)) {\n      options = cb\n      cb = cb.handler\n  }\n  \n  if (typeof cb === 'string') {\n      if (ctx[cb]) {\n          cb = ctx[cb]\n      } else {\n          cb = noop\n      }\n  }\n\n  watch(ctx, fn, cb, options)\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function watch (ctx, fn, cb, options) {\n  if (isObject(cb)) {\n      return createWatcher(ctx, fn, cb, options)\n  }\n\n  cb = cb || noop\n  options = options || {}\n  options.user = true\n  let Watcher\n  if (Watchers && Watchers.default) {\n\t  Watcher = Watchers.default\n  } else {\n\t  Watcher = Watchers\n  }\n  const watcher = new Watcher(ctx, fn, cb, options)\n\n  if (options.immediate) {\n      cb.call(ctx, watcher.value)\n  }\n\n  return function unwatch () {\n    watcher.teardown()\n  }\n};exports.watch = watch\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function invokeWithWatch (ctx, newVal, oldVal) {\n  const ctxMap = ctxTarget()\n  const ctxResut = ctxMap.map(item => item.is)\n  const current = ctx.vm.is\n  const cbName = ctx.cb.name\n  const fnName = ctx.fn === cbName ? ctx.fn : `${ctx.fn}${strToUpperCase(cbName)}`\n\n  if (ctxResut.includes(current)) {\n      if (watchMap.size) {\n          if (watchMap.has(current)) {\n              let fnMap = watchMap.get(current)\n              if (!fnMap.includes(fnName)) {\n                  fnMap.push(fnName)\n                  ctx.cb.call(ctx.vm, newVal, oldVal)\n              }\n          } else {\n              const funcNames = []\n              funcNames.push(fnName)\n              watchMap.set(current, funcNames)\n              ctx.cb.call(ctx.vm, newVal, oldVal)\n          }\n      } else {\n          const funcNames = []\n          funcNames.push(fnName)\n          watchMap.set(current, funcNames)\n          ctx.cb.call(ctx.vm, newVal, oldVal)\n      }\n  }\n\n  if (!called) {\n      wx.nextTick(() => {\n         watchMap.clear()\n         called = false\n      })\n\n      called = true\n  }\n};exports.invokeWithWatch = invokeWithWatch","let update = false\nlet add = false\nconst ctxStack = []\nlet temp = []\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function updateComputed (arg) {\n   if (!update) {\n      wx.nextTick(() => {\n         const targetMap = ctxTarget()\n\n         targetMap.map(ctx => {\n            const computedMap = ctx._computedMap\n            \n            if (computedMap && Object.keys(computedMap).length) {\n               try {\n                  if (arg == 'showUpdate') {\n                     ctx._rawData = JSON.parse(ctx._rawStringify)\n                     ctx._rawStringify = null\n                  } else {\n                     if (ctx._rawBack) {\n                        ctx._rawData = ctx._rawBack\n                        ctx._rawBack = null\n                     }\n                  }\n\n                  ctx.setData(computedMap, () => {\n                     ctx._computedMap = {}\n                  })\n               } catch (e) {\n                  throw e\n               }\n            }\n         })\n\n         update = false\n      })\n\n      update = true\n   }\n};exports.updateComputed = updateComputed\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function addStack (ctx) {\n   temp.push(ctx)\n\n   if (!add) {\n      wx.nextTick(() => {\n         if (ctxStack.length) {\n            const pages = getCurrentPages()\n            const isPage = pages[pages.length - 1].is\n      \n            ctxStack.map((stack, index) => {\n               let ctxMap = stack.map(page => page.is)\n               if (ctxMap.includes(isPage)) {\n                  ctxStack.splice(index, 1)\n               }\n            })\n         }\n         \n         ctxStack.push(temp)\n         \n         temp = []\n         add = false\n      })\n      \n      add = true\n   }\n};exports.addStack = addStack\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function ctxTarget () {\n   const pages = getCurrentPages()\n   const currentPage = pages[pages.length - 1]\n   let result = []\n\n   ctxStack.map(stack => {\n      stack.map(ctx => {\n         if (currentPage.is == ctx.is) {\n            result = stack\n         }\n      })\n   })\n\n   return result\n};exports.ctxTarget = ctxTarget\n","var __TEMP__ = require('./navigateTo');var navigateTo = __REQUIRE_DEFAULT__(__TEMP__);\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function navigate (event) {\n    let { url, routeType, delta } = event.currentTarget.dataset\n    let type = routeType ? routeType : 'navigateTo'\n    let num = delta ? delta : 1\n\n    if (routeType == 'navigateBack') {\n        const pages = getCurrentPages()\n        if (pages.length > 1) {\n            navigateTo(url = 'empty', type, { delta: Number(num) })\n        } else {\n            console.warn('navigateBack the navigate type must be navigateTo')\n        }\n    } else {\n        navigateTo(url, type)\n    }\n};exports.default = navigate","var __TEMP__ = require('../helper/utils');var isPlainObject = __TEMP__['isPlainObject'];\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function routeTo (...args) {\n  let url = args[0], type = 'navigateTo', params= {}\n\n  if (args.length == 2) {\n    if (isPlainObject(args[1])) {\n        params = args[1]\n    }\n\n    if (typeof args[1] == \"string\") {\n        type = args[1]\n    }\n  }\n\n  if (args.length == 3) {\n      type = args[1]\n      params = isPlainObject(args[2]) ? args[2] : {}\n  } \n  \n  if (type == 'navigateBack') {\n      try {\n        wx.navigateBack(params)\n      } catch (e) {\n        console.error(e)\n      }\n  } else {\n    if (!url) {\n        throw Error('The url should be string and not empty')\n    }\n   \n   const typeArray =  ['navigateTo', 'reLaunch', 'redirectTo']\n   if (typeArray.includes(type)) {  //可以传参的跳转方式\n       if (Object.keys(params).length) {  //带参数\n         for (const [key, value] of Object.entries(params)) {\n           if (url.indexOf('?') > 0) {\n               url += `&${key}=${value}`\n            } else {\n               url += `?${key}=${value}`\n            }\n         }\n       }\n \n       navigateTo(url, type)\n   } else {\n       try {\n         let index = url.indexOf('?')\n         let route = index > 0 ? url.substring(0, index) : url\n         wx.switchTab({ url: route })\n       } catch (err) {\n         console.error(err)\n       }\n    }\n  }\n};exports.default = routeTo\n\nfunction navigateTo (url, type) {\n  if (type == 'navigateTo') {\n      wx.navigateTo({ url })\n  } else if (type == 'reLaunch') {\n      wx.reLaunch({ url })\n  } else {\n      wx.redirectTo({ url })\n  }\n}","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function global (name, value) {\n    let globalData = getApp().globalData\n\n    if (arguments.length === 0) {\n        return globalData\n    }\n\n    if (isString(name)) {\n        const path = name.replace(/\\[(\\d+)\\]/g, '.$1').split('.')\n\n        if (arguments.length === 1) {\n            value = path.reduce((acc, cur) => acc[cur], globalData)\n            return value\n        }\n    \n        if (arguments.length === 2) {\n            path.reduce((acc, cur, index) => {\n                if (index == path.length - 1) {\n                    acc[cur] = value\n                }\n    \n                return acc[cur]\n            }, globalData)\n            \n            return globalData\n        }\n    }\n};exports.default = global\n\nfunction isString(val) {\n\treturn Object.prototype.toString.call(val) === '[object String]'\n}","var __TEMP__ = require('./utils');var equal = __TEMP__['equal'];var isMixObject = __TEMP__['isMixObject'];var isPlainObject = __TEMP__['isPlainObject'];\r\n\r\nlet watcherValue, equalValue, computedMap = {}\r\n\r\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function handleData (ctx) {\r\n  if (ctx.$store) {\r\n      const { _computedWatchers: watchersMap, $store: { _rawState: rawState } } = ctx\r\n      Object.keys(watchersMap).forEach(key => {\r\n        const value = watchersMap[key].value\r\n        if (isMixObject(value)) {\r\n            watcherValue = value\r\n            handleState(rawState)\r\n            computedMap[key] = equalValue\r\n        }\r\n      })\r\n    \r\n      ctx._rawData = { ...ctx._rawData, ...computedMap }\r\n      computedMap = {}\r\n  }\r\n};exports.default = handleData\r\n\r\nfunction handleState (data) {\r\n    for (let key in data) {\r\n      let value = data[key]\r\n\r\n      if (isMixObject(value)) {\r\n         if (Array.isArray(value)) {\r\n            if (equal(watcherValue, value)) {\r\n                equalValue = value\r\n                return\r\n            }\r\n\r\n            for (const item of value) {\r\n              if (isPlainObject(item)) {\r\n                   handleState(item)\r\n                   if (equal(watcherValue, item)) {\r\n                       equalValue = item\r\n                       break\r\n                   }\r\n                } else {\r\n                   handleState(item)\r\n                }\r\n            }\r\n         } else {\r\n            handleState(value)\r\n         }\r\n\r\n         if (isPlainObject(value)) {\r\n             if (equal(watcherValue, value)) {\r\n                 equalValue = value\r\n                 break\r\n             }\r\n         }\r\n      }\r\n    }\r\n}","var __TEMP__ = require('../navigate/index');var navigate = __REQUIRE_DEFAULT__(__TEMP__);\r\nvar __TEMP__ = require('../navigate/navigateTo');var routeTo = __REQUIRE_DEFAULT__(__TEMP__);\r\nvar __TEMP__ = require('../eventBus/index');var eventBus = __REQUIRE_DEFAULT__(__TEMP__);\r\nvar __TEMP__ = require('../axios/index');var httpRequest = __REQUIRE_DEFAULT__(__TEMP__);\r\nvar __TEMP__ = require('../globalProxy/globalData');var globalData = __REQUIRE_DEFAULT__(__TEMP__);\r\nvar __TEMP__ = require('./diff');var diffData = __REQUIRE_DEFAULT__(__TEMP__);\r\nvar __TEMP__ = require('../observer/watch');var globalWatch = __TEMP__['watch'];\r\n\r\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function hook (ctx, hookType) {\r\n    const { proxyData } = getApp()\r\n    if (proxyData && proxyData.store) {\r\n        ctx.$store = proxyData.store\r\n    }\r\n\t\r\n\tif (proxyData && proxyData.api) {\r\n        ctx.$api = proxyData.api\r\n    }\r\n\r\n    if (proxyData && proxyData.axios) {\r\n        const { axios } = proxyData\r\n        ctx.$axios = axios\r\n    } else {\r\n        ctx.$axios = httpRequest\r\n    }\r\n    ctx.$bus = eventBus\r\n\r\n    if (hookType == 'component') {\r\n        ctx.$route = routeTo\r\n        ctx.$global = globalData\r\n\r\n        ctx.routeTo = function (e) {\r\n          return navigate(e)\r\n        }\r\n    }\r\n    \r\n    ctx.$watch = function (fn, cb, op) {\r\n       return globalWatch(ctx, fn, cb, op)\r\n    }\r\n\r\n    const { setData, data } = ctx\r\n    ctx._setDataBackup = { setData }\r\n    ctx._rawData = JSON.parse(JSON.stringify(data))\r\n\r\n    ctx.setData = function (data, callback) {\r\n       diffData(ctx, data, callback)\r\n    }\r\n};exports.default = hook","class EventBus {\n  constructor () {\n    this.eventTask = {}\n  }\n\n  on(name, cb) {\n    if (!this.eventTask[name]) {\n      this.eventTask[name] = []\n    }\n\n    typeof cb === 'function' && this.eventTask[name].push(cb)\n  }\n\n  emit(name, ...args) {\n    let taskQueen = this.eventTask[name]\n    if (taskQueen && taskQueen.length > 0) {\n      taskQueen.forEach(cb => cb(...args))\n    }\n  }\n\n  off(name, cb) {\n    let taskQueen = this.eventTask[name]\n    if (taskQueen && taskQueen.length > 0) {\n      let index = taskQueen.indexOf(cb)\n      index != -1 && taskQueen.splice(index, 1)\n    }\n  }\n\n  once(name, cb) {\n    function callback (...args) {\n      this.off(name, cb)\n      cb(...args)\n    }\n    \n    typeof cb === 'function' && this.on(name, callback)\n  }\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = new EventBus();","var __TEMP__ = require('./utils');var getObjByKey = __TEMP__['getObjByKey'];var isNotEmptyObject = __TEMP__['isNotEmptyObject'];var noop = __TEMP__['noop'];\r\n\r\nconst ARRAYTYPE = '[object Array]'\r\nconst OBJECTTYPE = '[object Object]'\r\nconst FUNCTIONTYPE = '[object Function]'\r\nlet resultMap = [], ctxMap = []\r\n\r\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function diffData (ctx, data, cb) {\r\n    data = JSON.parse(JSON.stringify(data))\r\n    const diffResult = diff(data, ctx._rawData)\r\n    const result = getObjByKey(diffResult)\r\n    \r\n    let isNotEmptyObj = !!isNotEmptyObject(result)\r\n    cb = cb || noop\r\n    let { _setDataBackup: { setData } } = ctx\r\n\r\n    if (isNotEmptyObj) {\r\n        setData.call(ctx, result, cb)\r\n\r\n        resultMap.push(result)\r\n        ctxMap.push(ctx)\r\n        wx.nextTick(() => {\r\n            if (resultMap.length) {\r\n                resultMap.map((obj, index) => {\r\n                    let context = ctxMap[index]\r\n                    Object.keys(obj).forEach(key => {\r\n                        updateRawData(context, key, obj[key])\r\n                    })\r\n                })\r\n\r\n                resultMap = [], ctxMap = []\r\n            }\r\n        })\r\n    }\r\n};exports.default = diffData\r\n\r\nfunction updateRawData (ctx, key, value) {\r\n    const path = key.replace(/\\[(\\d+)\\]/g, '.$1').split('.')\r\n    \r\n    path.reduce((acc, cur, index) => {\r\n        if (index == path.length - 1) {\r\n            acc[cur] = value\r\n        }\r\n\r\n        return acc[cur]\r\n    }, ctx._rawData)\r\n}\r\n \r\nfunction diff (current, pre) {\r\n    const result = {}\r\n    syncKeys(current, pre)\r\n    _diff(current, pre, '', result)\r\n    return result\r\n}\r\n\r\nfunction syncKeys (current, pre) {\r\n    if (current === pre) return\r\n    const rootCurrentType = type(current)\r\n    const rootPreType = type(pre)\r\n    if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {\r\n          for (let key in pre) {\r\n              const currentValue = current[key]\r\n              if (currentValue === undefined) {\r\n                  current[key] = null\r\n              } else {\r\n                  syncKeys(currentValue, pre[key])\r\n              }\r\n          }\r\n    } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {\r\n        if (current.length >= pre.length) {\r\n            pre.forEach((item, index) => {\r\n                syncKeys(current[index], item)\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nfunction _diff (current, pre, path, result) {\r\n    if (current === pre) return\r\n    const rootCurrentType = type(current)\r\n    const rootPreType = type(pre)\r\n    if (rootCurrentType == OBJECTTYPE) {\r\n        if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {\r\n            setResult(result, path, current)\r\n        } else {\r\n            for (let key in current) {\r\n                const currentValue = current[key]\r\n                const preValue = pre[key]\r\n                const currentType = type(currentValue)\r\n                const preType = type(preValue)\r\n                if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {\r\n                    if (currentValue != pre[key]) {\r\n                        setResult(result, (path == '' ? '' : path + \".\") + key, currentValue)\r\n                    }\r\n                } else if (currentType == ARRAYTYPE) {\r\n                    if (preType != ARRAYTYPE) {\r\n                        setResult(result, (path == '' ? '' : path + \".\") + key, currentValue)\r\n                    } else {\r\n                        if (currentValue.length < preValue.length) {\r\n                            setResult(result, (path == '' ? '' : path + \".\") + key, currentValue)\r\n                        } else {\r\n                            currentValue.forEach((item, index) => {\r\n                                _diff(item, preValue[index], (path == '' ? '' : path + \".\") + key + '[' + index + ']', result)\r\n                            })\r\n                        }\r\n                    }\r\n                } else if (currentType == OBJECTTYPE) {\r\n                    if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {\r\n                        setResult(result, (path == '' ? '' : path + \".\") + key, currentValue)\r\n                    } else {\r\n                        for (let subKey in currentValue) {\r\n                            _diff(currentValue[subKey], preValue[subKey], (path == '' ? '' : path + \".\") + key + '.' + subKey, result)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else if (rootCurrentType == ARRAYTYPE) {\r\n        if (rootPreType != ARRAYTYPE) {\r\n            setResult(result, path, current)\r\n        } else {\r\n            if (current.length < pre.length) {\r\n                setResult(result, path, current)\r\n            } else {\r\n                current.forEach((item, index) => {\r\n                    _diff(item, pre[index], path + '[' + index + ']', result)\r\n                })\r\n            }\r\n        }\r\n    } else {\r\n        setResult(result, path, current)\r\n    }\r\n}\r\n\r\nfunction setResult (result, k, v) {\r\n    if (type(v) != FUNCTIONTYPE) {\r\n        result[k] = v\r\n    }\r\n}\r\n\r\nfunction type (obj) {\r\n    return Object.prototype.toString.call(obj)\r\n}","var __TEMP__ = require('../observer/index');var initState = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../observer/watch');var initWatch = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../helper/utils');var noop = __TEMP__['noop'];\nvar __TEMP__ = require('../helper/handleData');var handleData = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('../helper/hookEvent');var hookEvent = __REQUIRE_DEFAULT__(__TEMP__);\n\nconst myBehavior = Behavior({\n  lifetimes: {\n    attached: function () {\n      hookEvent(this, 'component')\n    }\n  }\n})\n\nconst originalComponent = Component\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = Component = function (config = {}) {\n  config.behaviors = [myBehavior]\n  \n  const lifeTimesBackup = {\n    attached: (config.lifetimes && config.lifetimes.attached) ? config.lifetimes.attached : noop,\n    detached: (config.lifetimes && config.lifetimes.detached) ? config.lifetimes.detached : noop,\n    configAttached: config.attached ? config.attached : noop,\n    configDetached: config.detached ? config.detached : noop\n  }\n\n  const pageLifetimesBackup = {\n    show: (config.pageLifetimes && config.pageLifetimes.show) ? config.pageLifetimes.show : noop\n  }\n\n  if (config.lifetimes) {\n      config.lifetimes = {\n        attached: function () {\n          initState(this, this.data, config.computed)\n          wx.nextTick(() => {\n            handleData(this)\n          })\n          \n          lifeTimesBackup.attached.call(this)\n        },\n    \n        detached: function () {\n          teardown(this)\n          lifeTimesBackup.detached.call(this)\n        }\n      }\n  } else {\n      if (config.attached && typeof config.attached === 'function') {\n          config.attached = function () {\n            initState(this, this.data, config.computed)\n            wx.nextTick(() => {\n              handleData(this)\n            })\n\n            lifeTimesBackup.configAttached.call(this)\n          }\n\n          config.detached = function () {\n             teardown(this)\n             ifeTimesBackup.configDetached.call(this)\n          }\n      } else {\n          config.lifetimes = {\n            attached: function () {\n              initState(this, this.data, config.computed)\n              wx.nextTick(() => {\n                handleData(this)\n              })\n              \n              lifeTimesBackup.attached.call(this)\n            },\n        \n            detached: function () {\n              teardown(this)\n              lifeTimesBackup.detached.call(this)\n            }\n          }\n      }\n  }\n\n  config.pageLifetimes = {\n    show: function () {\n       initWatch(this, config.watch)\n       pageLifetimesBackup.show && pageLifetimesBackup.show.call(this)\n    }\n  }\n\n  return originalComponent(config)\n};\n\nfunction teardown (ctx) {\n  const computedWatchers = ctx._computedWatchers\n  if (computedWatchers && Object.keys(computedWatchers).length) {\n      Object.keys(computedWatchers).forEach(key => computedWatchers[key].teardown())\n  }\n}"]}